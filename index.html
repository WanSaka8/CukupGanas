<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>🎮 Ultimate Brain Challenge</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #6a11cb;
      --secondary: #2575fc;
      --accent: #ff8a00;
      --correct: #00e676;
      --incorrect: #ff5252;
      --dark: #1a1a2e;
      --light: #f8f9fa;
      --riddle: #9c27b0;
      --puzzle: #3f51b5;
      --logic: #009688;
      --math: #f44336;
      --maze: #795548;
      --chess: #212121;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(45deg, var(--dark), #16213e);
      background-size: 400% 400%;
      animation: gradientBG 12s ease infinite;
      color: var(--light);
      min-height: 100vh;
      overflow-x: hidden;
    }

    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #app {
      padding: 2rem;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* Floating Animation */
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-15px); }
      100% { transform: translateY(0px); }
    }

    /* Particle Effects */
    .particle {
      position: absolute;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      pointer-events: none;
      z-index: -1;
    }

    /* Game Modes */
    .game-mode {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 2rem;
      border-radius: 15px;
      transition: all 0.3s ease;
      cursor: pointer;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .game-mode::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background: var(--accent);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .game-mode:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
    }

    .game-mode:hover::before {
      transform: scaleX(1);
    }

    .game-mode.riddle {
      border-top: 5px solid var(--riddle);
    }

    .game-mode.puzzle {
      border-top: 5px solid var(--puzzle);
    }

    .game-mode.logic {
      border-top: 5px solid var(--logic);
    }

    .game-mode.math {
      border-top: 5px solid var(--math);
    }

    .game-mode.maze {
      border-top: 5px solid var(--maze);
    }

    .game-mode.chess {
      border-top: 5px solid var(--chess);
    }

    .mode-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      display: inline-block;
      animation: float 4s ease-in-out infinite;
    }

    /* Home Page */
    .home-container {
      max-width: 900px;
      width: 100%;
      text-align: center;
      animation: fadeIn 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .title {
      font-family: 'Press Start 2P', cursive;
      font-size: 3rem;
      font-weight: 700;
      margin-bottom: 1.5rem;
      background: linear-gradient(to right, var(--light), var(--accent));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      line-height: 1.3;
    }

    .subtitle {
      font-size: 1.5rem;
      opacity: 0.9;
      margin-bottom: 3rem;
    }

    .game-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin: 3rem 0;
    }

    .start-button {
      background: linear-gradient(45deg, var(--accent), #ff416c);
      color: white;
      padding: 1.2rem 2.5rem;
      font-size: 1.2rem;
      font-weight: 600;
      border-radius: 50px;
      border: none;
      cursor: pointer;
      margin-top: 1rem;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .start-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.5s;
    }

    .start-button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
    }

    .start-button:hover::before {
      left: 100%;
    }

    /* Game Page */
    .game-container {
      max-width: 800px;
      width: 100%;
      background: rgba(26, 26, 46, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
      padding: 2.5rem;
      animation: slideUp 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      position: relative;
      overflow: hidden;
      border-top: 5px solid var(--accent);
    }

    .game-container::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
      animation: rotate 20s linear infinite;
      z-index: -1;
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .timer-container {
      display: flex;
      align-items: center;
      gap: 0.8rem;
    }

    .timer-circle {
      position: relative;
      width: 60px;
      height: 60px;
    }

    .timer-text {
      font-size: 1.3rem;
      font-weight: 600;
    }

    .score {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(to right, var(--accent), var(--correct));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .question-container {
      margin: 2rem 0;
    }

    .question-type {
      display: inline-block;
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 1rem;
      background: var(--accent);
      color: white;
    }

    .question {
      font-size: 1.8rem;
      line-height: 1.5;
      margin-bottom: 2.5rem;
      position: relative;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      border-left: 4px solid var(--accent);
    }

    .question::before {
      content: '?';
      position: absolute;
      right: 1rem;
      top: -1rem;
      font-size: 5rem;
      opacity: 0.1;
      z-index: -1;
    }

    .options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .option-button {
      padding: 1.2rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      color: var(--light);
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
    }

    .option-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-3px);
    }

    .option-button.correct {
      background: var(--correct);
      color: white;
      animation: pulse 0.5s ease;
    }

    .option-button.incorrect {
      background: var(--incorrect);
      color: white;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .answer-input {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .answer-field {
      flex: 1;
      padding: 1.2rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      color: white;
      font-size: 1.1rem;
      backdrop-filter: blur(5px);
    }

    .answer-field:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(255, 138, 0, 0.3);
    }

    .submit-button {
      padding: 0 2rem;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .submit-button:hover {
      background: #ff6b00;
      transform: translateY(-2px);
    }

    .feedback {
      margin-top: 2rem;
      animation: fadeIn 0.5s ease;
    }

    .feedback-message {
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 1.5rem;
      font-size: 1.2rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.8rem;
      flex-direction: column;
    }

    .correct-feedback {
      background: rgba(0, 230, 118, 0.2);
      border: 1px solid var(--correct);
      color: var(--correct);
    }

    .incorrect-feedback {
      background: rgba(255, 82, 82, 0.2);
      border: 1px solid var(--incorrect);
      color: var(--incorrect);
    }

    .explanation {
      font-size: 0.9rem;
      font-weight: normal;
      margin-top: 0.5rem;
      text-align: center;
      opacity: 0.8;
    }

    .next-button {
      width: 100%;
      padding: 1.2rem;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .next-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }

    /* Maze Game */
    .maze-container {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
    }

    .maze-level {
      font-size: 1.5rem;
      text-align: center;
      margin-bottom: 1rem;
      font-weight: bold;
    }

    .maze-board {
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      grid-template-rows: repeat(var(--rows), 1fr);
      gap: 2px;
      width: 100%;
      aspect-ratio: 1/1;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      margin-bottom: 1rem;
    }

    .maze-cell {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .maze-wall {
      background: #333;
    }

    .maze-path {
      background: rgba(255, 255, 255, 0.05);
    }

    .maze-start {
      background: #4CAF50;
    }

    .maze-end {
      background: #F44336;
    }

    .maze-player {
      background: #2196F3;
      border-radius: 50%;
      width: 80%;
      height: 80%;
      z-index: 2;
    }

    .maze-visited {
      background: rgba(33, 150, 243, 0.2);
    }

    .maze-controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
    }

    .maze-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 0.5rem;
    }

    .maze-button {
      padding: 0.8rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      color: white;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .maze-button:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .maze-button:active {
      transform: scale(0.95);
    }

    /* Chess Game */
    .chess-container {
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
    }

    .chess-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      width: 100%;
      aspect-ratio: 1/1;
      border: 2px solid rgba(255, 255, 255, 0.2);
      margin-bottom: 1rem;
    }

    .chess-square {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .chess-square.light {
      background: #f0d9b5;
    }

    .chess-square.dark {
      background: #b58863;
    }

    .chess-square.highlight {
      background: rgba(0, 255, 0, 0.3);
    }

    .chess-piece {
      width: 80%;
      height: 80%;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      cursor: pointer;
      z-index: 2;
      font-size: 2.5rem; /* Adjusted for better visibility of text pieces */
      line-height: 1; /* Ensure text is centered */
      display: flex; /* For centering text */
      align-items: center; /* For centering text */
      justify-content: center; /* For centering text */
    }

    .chess-piece.selected {
      box-shadow: 0 0 10px 5px rgba(255, 255, 0, 0.5);
    }

    .chess-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 1rem;
    }

    .chess-info {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .chess-turn {
      font-size: 1.2rem;
      font-weight: bold;
    }

    .chess-status {
      font-size: 1rem;
      opacity: 0.8;
    }

    /* Results Page */
    .results-container {
      max-width: 800px;
      width: 100%;
      animation: fadeIn 0.8s ease;
    }

    .results-card {
      background: rgba(26, 26, 46, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 3rem;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
      text-align: center;
      position: relative;
      overflow: hidden;
      border-top: 5px solid var(--accent);
    }

    .results-card::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
      z-index: -1;
    }

    .results-title {
      font-size: 2.5rem;
      margin-bottom: 2rem;
      background: linear-gradient(to right, var(--light), var(--accent));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .score-display {
      margin: 3rem 0;
      position: relative;
    }

    .score-circle {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin: 0 auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      position: relative;
      animation: float 6s ease-in-out infinite;
    }

    .score-circle::before {
      content: '';
      position: absolute;
      inset: -10px;
      border-radius: 50%;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      z-index: -1;
      filter: blur(20px);
      opacity: 0.6;
    }

    .score-value {
      font-size: 4.5rem;
      font-weight: 700;
      line-height: 1;
      background: linear-gradient(to bottom, var(--light), var(--accent));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .score-label {
      font-size: 1.2rem;
      opacity: 0.8;
    }

    .feedback-title {
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .feedback-text {
      font-size: 1.2rem;
      opacity: 0.9;
      margin-bottom: 3rem;
      line-height: 1.6;
    }

    .actions {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      margin-top: 2rem;
    }

    .action-button {
      padding: 1.2rem 2.5rem;
      border-radius: 50px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 180px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      border: none;
    }

    .play-again {
      background: linear-gradient(45deg, var(--accent), #ff416c);
      color: white;
    }

    .go-home {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .action-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(50px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes confetti {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .title {
        font-size: 2rem;
      }
      
      .subtitle {
        font-size: 1.2rem;
      }
      
      .game-modes {
        grid-template-columns: 1fr;
      }
      
      .game-container, .results-card {
        padding: 1.5rem;
      }
      
      .question {
        font-size: 1.5rem;
      }
      
      .options {
        grid-template-columns: 1fr;
      }
      
      .answer-input {
        flex-direction: column;
      }
      
      .submit-button {
        padding: 1.2rem;
        width: 100%;
      }
      
      .actions {
        flex-direction: column;
      }
      
      .action-button {
        width: 100%;
      }

      .maze-buttons {
        grid-template-columns: 1fr; /* Changed for better mobile layout */
      }
      .chess-piece {
        font-size: 1.8rem; /* Adjust chess piece size for mobile */
      }
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Content will be dynamically rendered here -->
  </div>

  <script>
    // Enhanced Game Data with Multiple Types
    const questions = {
      riddle: [
        {
          type: 'riddle',
          text: 'Aku memiliki kota tetapi tidak ada rumah, aku memiliki gunung tetapi tidak ada pohon, aku memiliki air tetapi tidak ada ikan. Apakah aku?',
          answer: 'peta',
          hint: 'Berkaitan dengan geografi'
        },
        {
          type: 'riddle',
          text: 'Semakin banyak kamu mengambil, semakin banyak kamu meninggalkan. Apakah aku?',
          answer: 'langkah',
          hint: 'Berkaitan dengan perjalanan'
        },
        {
          type: 'riddle',
          text: 'Aku berbicara tanpa mulut dan mendengar tanpa telinga. Aku tidak memiliki tubuh, tetapi aku hidup dengan angin. Apakah aku?',
          answer: 'gema',
          hint: 'Berkaitan dengan suara'
        },
        {
          type: 'riddle',
          text: 'Aku ringan seperti bulu, tetapi orang terkuat pun tidak bisa menahanku lebih dari 5 menit. Apakah aku?',
          answer: 'napas',
          hint: 'Berkaitan dengan tubuh manusia'
        },
        {
          type: 'riddle',
          text: 'Aku bukan hidup, tapi aku bisa mati. Aku bukan cairan, tapi aku bisa mengalir. Apakah aku?',
          answer: 'api',
          hint: 'Unsur alam'
        }
      ],
      puzzle: [
        {
          type: 'multiple-choice',
          text: 'Jika 2 orang ayah dan 2 orang anak pergi memancing, berapa minimal orang yang ada di situ?',
          options: ['3', '4', '2', '5'],
          answer: '3',
          explanation: 'Mereka adalah kakek, ayah, dan anak (total 3 orang)'
        },
        {
          type: 'multiple-choice',
          text: 'Apa yang memiliki tangan tetapi tidak bisa bertepuk tangan?',
          options: ['Jam', 'Pohon', 'Boneka', 'Robot'],
          answer: 'Jam',
          explanation: 'Mengacu pada jarum jam'
        },
        {
          type: 'multiple-choice',
          text: 'Apa yang memiliki 13 hati tetapi tidak memiliki organ tubuh lainnya?',
          options: ['Deck kartu', 'Manusia robot', 'Alien', 'Tas'],
          answer: 'Deck kartu',
          explanation: 'Mengacu pada 13 hati dalam satu set kartu remi'
        },
        {
          type: 'multiple-choice',
          text: 'Jika sebuah pesawat jatuh di perbatasan antara Amerika Serikat dan Kanada, di mana korban akan dikuburkan?',
          options: ['Amerika Serikat', 'Kanada', 'Keduanya', 'Tidak dikuburkan'],
          answer: 'Tidak dikuburkan',
          explanation: 'Korban kecelakaan pesawat tidak dikuburkan'
        }
      ],
      logic: [
        {
          type: 'sequence',
          text: 'Lanjutkan urutan berikut: O, T, T, F, F, S, S, ...',
          answer: 'E',
          explanation: 'Huruf pertama angka dalam bahasa Inggris: One, Two, Three, Four, Five, Six, Seven, Eight'
        },
        {
          type: 'sequence',
          text: '2, 10, 12, 16, 17, 18, 19, ...',
          answer: '200',
          explanation: 'Angka-angka yang dimulai dengan huruf D dalam bahasa Inggris'
        },
        {
          type: 'logic-puzzle',
          text: 'Ada 3 lampu di ruang bawah tanah dan 3 saklar di lantai atas. Bagaimana kamu menentukan saklar mana yang mengendalikan lampu mana jika kamu hanya bisa turun ke ruang bawah tanah sekali?',
          answer: 'Nyalakan saklar pertama selama 5 menit, matikan, nyalakan saklar kedua, lalu periksa. Lampu yang panas tapi mati adalah saklar pertama, yang menyala adalah saklar kedua, dan yang dingin adalah saklar ketiga.',
          hint: 'Gunakan panas lampu sebagai petunjuk'
        }
      ],
      math: [
        {
          type: 'calculation',
          text: 'Jika 1+1=2, 2+2=4, 4+4=8, maka berapa 8+8?',
          answer: '16',
          explanation: 'Ini adalah deret penggandaan'
        },
        {
          type: 'word-problem',
          text: 'Seorang ayah dan anak memiliki total usia 66 tahun. Usia ayah adalah kebalikan dari usia anak (misal anak 24 tahun, ayah 42 tahun). Berapa usia mereka sebenarnya?',
          answer: '51 dan 15',
          explanation: '51 + 15 = 66 dan 51 adalah kebalikan dari 15'
        },
        {
          type: 'tricky-math',
          text: 'Berapa kali kamu bisa mengurangi 5 dari 25?',
          answer: '1',
          explanation: 'Setelah dikurangi sekali, angka menjadi 20, jadi kamu tidak lagi mengurangi dari 25'
        }
      ]
    };

    // Maze Levels (20 extreme levels) - Data kept as is
    const mazeLevels = [
      // Level 1-5: Basic mazes
      {
        rows: 5, cols: 5,
        start: {row: 0, col: 0},
        end: {row: 4, col: 4},
        walls: [
          [0,1], [1,1], [1,3], [2,1], [2,3], [3,1], [3,3]
        ]
      },
      {
        rows: 7, cols: 7,
        start: {row: 0, col: 0},
        end: {row: 6, col: 6},
        walls: [
          [0,2], [0,4], [1,2], [1,4], [2,0], [2,1], [2,2], [2,4], [2,5], [2,6],
          [3,2], [3,4], [4,2], [4,4], [5,2], [5,4], [6,2], [6,4]
        ]
      },
      {
        rows: 8, cols: 8,
        start: {row: 0, col: 0},
        end: {row: 7, col: 7},
        walls: [
          [0,1], [0,3], [0,5], [1,1], [1,3], [1,5], [2,1], [2,3], [2,5],
          [3,1], [3,3], [3,5], [4,1], [4,3], [4,5], [5,1], [5,3], [5,5],
          [6,1], [6,3], [6,5], [7,1], [7,3], [7,5]
        ]
      },
      {
        rows: 10, cols: 10,
        start: {row: 0, col: 0},
        end: {row: 9, col: 9},
        walls: [
          [0,1], [0,3], [0,5], [0,7], [1,1], [1,3], [1,5], [1,7],
          [2,1], [2,3], [2,5], [2,7], [3,1], [3,3], [3,5], [3,7],
          [4,1], [4,3], [4,5], [4,7], [5,1], [5,3], [5,5], [5,7],
          [6,1], [6,3], [6,5], [6,7], [7,1], [7,3], [7,5], [7,7],
          [8,1], [8,3], [8,5], [8,7], [9,1], [9,3], [9,5], [9,7]
        ]
      },
      {
        rows: 12, cols: 12,
        start: {row: 0, col: 0},
        end: {row: 11, col: 11},
        walls: [
          [0,1], [0,3], [0,5], [0,7], [0,9], [1,1], [1,3], [1,5], [1,7], [1,9],
          [2,1], [2,3], [2,5], [2,7], [2,9], [3,1], [3,3], [3,5], [3,7], [3,9],
          [4,1], [4,3], [4,5], [4,7], [4,9], [5,1], [5,3], [5,5], [5,7], [5,9],
          [6,1], [6,3], [6,5], [6,7], [6,9], [7,1], [7,3], [7,5], [7,7], [7,9],
          [8,1], [8,3], [8,5], [8,7], [8,9], [9,1], [9,3], [9,5], [9,7], [9,9],
          [10,1], [10,3], [10,5], [10,7], [10,9], [11,1], [11,3], [11,5], [11,7], [11,9]
        ]
      },
      // Level 6-10: More complex patterns
      {
        rows: 15, cols: 15,
        start: {row: 0, col: 0},
        end: {row: 14, col: 14},
        walls: [
          [0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
          [1,13], [2,13], [3,13], [4,13], [5,13], [6,13], [7,13], [8,13], [9,13], [10,13], [11,13], [12,13], [13,13],
          [13,0], [13,1], [13,2], [13,3], [13,4], [13,5], [13,6], [13,7], [13,8], [13,9], [13,10], [13,11], [13,12],
          [1,0], [2,0], [3,0], [4,0], [5,0], [6,0], [7,0], [8,0], [9,0], [10,0], [11,0], [12,0],
          // Inner walls
          [2,2], [2,4], [2,6], [2,8], [2,10], [2,12],
          [4,2], [4,4], [4,6], [4,8], [4,10], [4,12],
          [6,2], [6,4], [6,6], [6,8], [6,10], [6,12],
          [8,2], [8,4], [8,6], [8,8], [8,10], [8,12],
          [10,2], [10,4], [10,6], [10,8], [10,10], [10,12],
          [12,2], [12,4], [12,6], [12,8], [12,10], [12,12]
        ]
      },
      {
        rows: 15, cols: 15,
        start: {row: 0, col: 0},
        end: {row: 14, col: 14},
        walls: [
          // Spiral pattern
          [0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
          [1,13], [2,13], [3,13], [4,13], [5,13], [6,13], [7,13], [8,13], [9,13], [10,13], [11,13], [12,13],
          [13,13], [13,12], [13,11], [13,10], [13,9], [13,8], [13,7], [13,6], [13,5], [13,4], [13,3], [13,2], [13,1], [13,0],
          [12,0], [11,0], [10,0], [9,0], [8,0], [7,0], [6,0], [5,0], [4,0], [3,0], [2,0], [1,0],
          [1,1], [1,2], [1,3], [1,4], [1,5], [1,6], [1,7], [1,8], [1,9], [1,10], [1,11], [1,12],
          [2,12], [3,12], [4,12], [5,12], [6,12], [7,12], [8,12], [9,12], [10,12], [11,12],
          [11,11], [11,10], [11,9], [11,8], [11,7], [11,6], [11,5], [11,4], [11,3], [11,2], [11,1],
          [10,1], [9,1], [8,1], [7,1], [6,1], [5,1], [4,1], [3,1], [2,1],
          [2,2], [2,3], [2,4], [2,5], [2,6], [2,7], [2,8], [2,9], [2,10], [2,11],
          [3,11], [4,11], [5,11], [6,11], [7,11], [8,11], [9,11], [10,11],
          [10,10], [10,9], [10,8], [10,7], [10,6], [10,5], [10,4], [10,3], [10,2],
          [9,2], [8,2], [7,2], [6,2], [5,2], [4,2], [3,2],
          [3,3], [3,4], [3,5], [3,6], [3,7], [3,8], [3,9], [3,10],
          [4,10], [5,10], [6,10], [7,10], [8,10], [9,10],
          [9,9], [9,8], [9,7], [9,6], [9,5], [9,4], [9,3],
          [8,3], [7,3], [6,3], [5,3], [4,3],
          [4,4], [4,5], [4,6], [4,7], [4,8], [4,9],
          [5,9], [6,9], [7,9], [8,9],
          [8,8], [8,7], [8,6], [8,5], [8,4],
          [7,4], [6,4], [5,4],
          [5,5], [5,6], [5,7], [5,8],
          [6,8], [7,8],
          [7,7], [7,6], [7,5],
          [6,5],
          [6,6]
        ]
      },
      {
        rows: 15, cols: 15,
        start: {row: 0, col: 0},
        end: {row: 14, col: 14},
        walls: [
          // Checkerboard pattern with openings
          [0,1], [0,3], [0,5], [0,7], [0,9], [0,11], [0,13],
          [1,0], [1,2], [1,4], [1,6], [1,8], [1,10], [1,12], [1,14],
          [2,1], [2,3], [2,5], [2,7], [2,9], [2,11], [2,13],
          [3,0], [3,2], [3,4], [3,6], [3,8], [3,10], [3,12], [3,14],
          [4,1], [4,3], [4,5], [4,7], [4,9], [4,11], [4,13],
          [5,0], [5,2], [5,4], [5,6], [5,8], [5,10], [5,12], [5,14],
          [6,1], [6,3], [6,5], [6,7], [6,9], [6,11], [6,13],
          [7,0], [7,2], [7,4], [7,6], [7,8], [7,10], [7,12], [7,14],
          [8,1], [8,3], [8,5], [8,7], [8,9], [8,11], [8,13],
          [9,0], [9,2], [9,4], [9,6], [9,8], [9,10], [9,12], [9,14],
          [10,1], [10,3], [10,5], [10,7], [10,9], [10,11], [10,13],
          [11,0], [11,2], [11,4], [11,6], [11,8], [11,10], [11,12], [11,14],
          [12,1], [12,3], [12,5], [12,7], [12,9], [12,11], [12,13],
          [13,0], [13,2], [13,4], [13,6], [13,8], [13,10], [13,12], [13,14],
          [14,1], [14,3], [14,5], [14,7], [14,9], [14,11], [14,13],
          // Openings to create a path
          [0,0], [0,14], [14,0], [14,14] // These were likely intended to be removed from walls, not added as walls
        ]
      },
      {
        rows: 15, cols: 15,
        start: {row: 0, col: 0},
        end: {row: 14, col: 14},
        walls: [
          // Maze with multiple paths but only one correct
          [0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
          [1,0], [1,2], [1,4], [1,6], [1,8], [1,10], [1,12], [1,14],
          [2,1], [2,3], [2,5], [2,7], [2,9], [2,11], [2,13],
          [3,0], [3,2], [3,4], [3,6], [3,8], [3,10], [3,12], [3,14],
          [4,1], [4,3], [4,5], [4,7], [4,9], [4,11], [4,13],
          [5,0], [5,2], [5,4], [5,6], [5,8], [5,10], [5,12], [5,14],
          [6,1], [6,3], [6,5], [6,7], [6,9], [6,11], [6,13],
          [7,0], [7,2], [7,4], [7,6], [7,8], [7,10], [7,12], [7,14],
          [8,1], [8,3], [8,5], [8,7], [8,9], [8,11], [8,13],
          [9,0], [9,2], [9,4], [9,6], [9,8], [9,10], [9,12], [9,14],
          [10,1], [10,3], [10,5], [10,7], [10,9], [10,11], [10,13],
          [11,0], [11,2], [11,4], [11,6], [11,8], [11,10], [11,12], [11,14],
          [12,1], [12,3], [12,5], [12,7], [12,9], [12,11], [12,13],
          [13,0], [13,2], [13,4], [13,6], [13,8], [13,10], [13,12], [13,14],
          [14,1], [14,3], [14,5], [14,7], [14,9], [14,11], [14,13],
          // Correct path openings (These should NOT be walls)
          // [0,0], [1,1], [2,0], [3,1], [4,0], [5,1], [6,0], [7,1], [8,0], [9,1], [10,0], [11,1], [12,0], [13,1], [14,0]
        ].filter(w => !([
          [0,0], [1,1], [2,0], [3,1], [4,0], [5,1], [6,0], [7,1], [8,0], [9,1], [10,0], [11,1], [12,0], [13,1], [14,0]
        ].some(p => p[0] === w[0] && p[1] === w[1]))) // Filter out path openings from walls
      },
      {
        rows: 15, cols: 15,
        start: {row: 0, col: 0},
        end: {row: 14, col: 14},
        walls: [
          // Complex maze with dead ends
          [0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13],
          [1,0], [1,2], [1,4], [1,6], [1,8], [1,10], [1,12], [1,14],
          [2,1], [2,3], [2,5], [2,7], [2,9], [2,11], [2,13],
          [3,0], [3,2], [3,4], [3,6], [3,8], [3,10], [3,12], [3,14],
          [4,1], [4,3], [4,5], [4,7], [4,9], [4,11], [4,13],
          [5,0], [5,2], [5,4], [5,6], [5,8], [5,10], [5,12], [5,14],
          [6,1], [6,3], [6,5], [6,7], [6,9], [6,11], [6,13],
          [7,0], [7,2], [7,4], [7,6], [7,8], [7,10], [7,12], [7,14],
          [8,1], [8,3], [8,5], [8,7], [8,9], [8,11], [8,13],
          [9,0], [9,2], [9,4], [9,6], [9,8], [9,10], [9,12], [9,14],
          [10,1], [10,3], [10,5], [10,7], [10,9], [10,11], [10,13],
          [11,0], [11,2], [11,4], [11,6], [11,8], [11,10], [11,12], [11,14],
          [12,1], [12,3], [12,5], [12,7], [12,9], [12,11], [12,13],
          [13,0], [13,2], [13,4], [13,6], [13,8], [13,10], [13,12], [13,14],
          [14,1], [14,3], [14,5], [14,7], [14,9], [14,11], [14,13],
          // Correct path openings with some dead ends (These should NOT be walls)
          // [0,0], [1,1], [2,2], [3,3], [4,4], [5,5], [6,6], [7,7], [8,8], [9,9], [10,10], [11,11], [12,12], [13,13], [14,14],
          // Dead ends (These ARE walls)
          [1,3], [1,5], [1,7], [1,9], [1,11], [1,13],
          [3,1], [3,5], [3,7], [3,9], [3,11], [3,13],
          [5,1], [5,3], [5,7], [5,9], [5,11], [5,13],
          [7,1], [7,3], [7,5], [7,9], [7,11], [7,13],
          [9,1], [9,3], [9,5], [9,7], [9,11], [9,13],
          [11,1], [11,3], [11,5], [11,7], [11,9], [11,13],
          [13,1], [13,3], [13,5], [13,7], [13,9], [13,11]
        ].filter(w => !([
          [0,0], [1,1], [2,2], [3,3], [4,4], [5,5], [6,6], [7,7], [8,8], [9,9], [10,10], [11,11], [12,12], [13,13], [14,14]
        ].some(p => p[0] === w[0] && p[1] === w[1]))) // Filter out path openings
      },
      // Level 11-15: Even more complex mazes
      {
        rows: 20, cols: 20,
        start: {row: 0, col: 0},
        end: {row: 19, col: 19},
        walls: [
          // Complex pattern with multiple paths
          [0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13], [0,14], [0,15], [0,16], [0,17], [0,18],
          [1,0], [1,2], [1,4], [1,6], [1,8], [1,10], [1,12], [1,14], [1,16], [1,18],
          [2,1], [2,3], [2,5], [2,7], [2,9], [2,11], [2,13], [2,15], [2,17], [2,19],
          [3,0], [3,2], [3,4], [3,6], [3,8], [3,10], [3,12], [3,14], [3,16], [3,18],
          [4,1], [4,3], [4,5], [4,7], [4,9], [4,11], [4,13], [4,15], [4,17], [4,19],
          [5,0], [5,2], [5,4], [5,6], [5,8], [5,10], [5,12], [5,14], [5,16], [5,18],
          [6,1], [6,3], [6,5], [6,7], [6,9], [6,11], [6,13], [6,15], [6,17], [6,19],
          [7,0], [7,2], [7,4], [7,6], [7,8], [7,10], [7,12], [7,14], [7,16], [7,18],
          [8,1], [8,3], [8,5], [8,7], [8,9], [8,11], [8,13], [8,15], [8,17], [8,19],
          [9,0], [9,2], [9,4], [9,6], [9,8], [9,10], [9,12], [9,14], [9,16], [9,18],
          [10,1], [10,3], [10,5], [10,7], [10,9], [10,11], [10,13], [10,15], [10,17], [10,19],
          [11,0], [11,2], [11,4], [11,6], [11,8], [11,10], [11,12], [11,14], [11,16], [11,18],
          [12,1], [12,3], [12,5], [12,7], [12,9], [12,11], [12,13], [12,15], [12,17], [12,19],
          [13,0], [13,2], [13,4], [13,6], [13,8], [13,10], [13,12], [13,14], [13,16], [13,18],
          [14,1], [14,3], [14,5], [14,7], [14,9], [14,11], [14,13], [14,15], [14,17], [14,19],
          [15,0], [15,2], [15,4], [15,6], [15,8], [15,10], [15,12], [15,14], [15,16], [15,18],
          [16,1], [16,3], [16,5], [16,7], [16,9], [16,11], [16,13], [16,15], [16,17], [16,19],
          [17,0], [17,2], [17,4], [17,6], [17,8], [17,10], [17,12], [17,14], [17,16], [17,18],
          [18,1], [18,3], [18,5], [18,7], [18,9], [18,11], [18,13], [18,15], [18,17], [18,19],
          [19,0], [19,2], [19,4], [19,6], [19,8], [19,10], [19,12], [19,14], [19,16], [19,18],
          // Correct path (These should NOT be walls)
          // [0,0], [1,1], [2,2], [3,3], [4,4], [5,5], [6,6], [7,7], [8,8], [9,9], [10,10], [11,11], [12,12], [13,13], [14,14], [15,15], [16,16], [17,17], [18,18], [19,19],
          // Some openings to create alternative paths (These should NOT be walls)
          // [1,3], [1,5], [1,7], [1,9], [1,11], [1,13], [1,15], [1,17],
          // [3,1], [3,5], [3,7], [3,9], [3,11], [3,13], [3,15], [3,17],
          // ... (and so on for other openings)
        ].filter(w => !([
          [0,0], [1,1], [2,2], [3,3], [4,4], [5,5], [6,6], [7,7], [8,8], [9,9], [10,10], [11,11], [12,12], [13,13], [14,14], [15,15], [16,16], [17,17], [18,18], [19,19],
          [1,3], [1,5], [1,7], [1,9], [1,11], [1,13], [1,15], [1,17],
          [3,1], [3,5], [3,7], [3,9], [3,11], [3,13], [3,15], [3,17],
          [5,1], [5,3], [5,7], [5,9], [5,11], [5,13], [5,15], [5,17],
          [7,1], [7,3], [7,5], [7,9], [7,11], [7,13], [7,15], [7,17],
          [9,1], [9,3], [9,5], [9,7], [9,11], [9,13], [9,15], [9,17],
          [11,1], [11,3], [11,5], [11,7], [11,9], [11,13], [11,15], [11,17],
          [13,1], [13,3], [13,5], [13,7], [13,9], [13,11], [13,15], [13,17],
          [15,1], [15,3], [15,5], [15,7], [15,9], [15,11], [15,13], [15,17],
          [17,1], [17,3], [17,5], [17,7], [17,9], [17,11], [17,13], [17,15]
        ].some(p => p[0] === w[0] && p[1] === w[1])))
      },
      // Level 16-20: Extreme mazes
      {
        rows: 20, cols: 20,
        start: {row: 0, col: 0},
        end: {row: 19, col: 19},
        walls: [
          // Almost completely filled with walls
          [0,1], [0,2], [0,3], [0,4], [0,5], [0,6], [0,7], [0,8], [0,9], [0,10], [0,11], [0,12], [0,13], [0,14], [0,15], [0,16], [0,17], [0,18], [0,19],
          [1,0], [1,1], [1,2], [1,3], [1,4], [1,5], [1,6], [1,7], [1,8], [1,9], [1,10], [1,11], [1,12], [1,13], [1,14], [1,15], [1,16], [1,17], [1,18], [1,19],
          [2,0], [2,1], [2,2], [2,3], [2,4], [2,5], [2,6], [2,7], [2,8], [2,9], [2,10], [2,11], [2,12], [2,13], [2,14], [2,15], [2,16], [2,17], [2,18], [2,19],
          [3,0], [3,1], [3,2], [3,3], [3,4], [3,5], [3,6], [3,7], [3,8], [3,9], [3,10], [3,11], [3,12], [3,13], [3,14], [3,15], [3,16], [3,17], [3,18], [3,19],
          [4,0], [4,1], [4,2], [4,3], [4,4], [4,5], [4,6], [4,7], [4,8], [4,9], [4,10], [4,11], [4,12], [4,13], [4,14], [4,15], [4,16], [4,17], [4,18], [4,19],
          [5,0], [5,1], [5,2], [5,3], [5,4], [5,5], [5,6], [5,7], [5,8], [5,9], [5,10], [5,11], [5,12], [5,13], [5,14], [5,15], [5,16], [5,17], [5,18], [5,19],
          [6,0], [6,1], [6,2], [6,3], [6,4], [6,5], [6,6], [6,7], [6,8], [6,9], [6,10], [6,11], [6,12], [6,13], [6,14], [6,15], [6,16], [6,17], [6,18], [6,19],
          [7,0], [7,1], [7,2], [7,3], [7,4], [7,5], [7,6], [7,7], [7,8], [7,9], [7,10], [7,11], [7,12], [7,13], [7,14], [7,15], [7,16], [7,17], [7,18], [7,19],
          [8,0], [8,1], [8,2], [8,3], [8,4], [8,5], [8,6], [8,7], [8,8], [8,9], [8,10], [8,11], [8,12], [8,13], [8,14], [8,15], [8,16], [8,17], [8,18], [8,19],
          [9,0], [9,1], [9,2], [9,3], [9,4], [9,5], [9,6], [9,7], [9,8], [9,9], [9,10], [9,11], [9,12], [9,13], [9,14], [9,15], [9,16], [9,17], [9,18], [9,19],
          [10,0], [10,1], [10,2], [10,3], [10,4], [10,5], [10,6], [10,7], [10,8], [10,9], [10,10], [10,11], [10,12], [10,13], [10,14], [10,15], [10,16], [10,17], [10,18], [10,19],
          [11,0], [11,1], [11,2], [11,3], [11,4], [11,5], [11,6], [11,7], [11,8], [11,9], [11,10], [11,11], [11,12], [11,13], [11,14], [11,15], [11,16], [11,17], [11,18], [11,19],
          [12,0], [12,1], [12,2], [12,3], [12,4], [12,5], [12,6], [12,7], [12,8], [12,9], [12,10], [12,11], [12,12], [12,13], [12,14], [12,15], [12,16], [12,17], [12,18], [12,19],
          [13,0], [13,1], [13,2], [13,3], [13,4], [13,5], [13,6], [13,7], [13,8], [13,9], [13,10], [13,11], [13,12], [13,13], [13,14], [13,15], [13,16], [13,17], [13,18], [13,19],
          [14,0], [14,1], [14,2], [14,3], [14,4], [14,5], [14,6], [14,7], [14,8], [14,9], [14,10], [14,11], [14,12], [14,13], [14,14], [14,15], [14,16], [14,17], [14,18], [14,19],
          [15,0], [15,1], [15,2], [15,3], [15,4], [15,5], [15,6], [15,7], [15,8], [15,9], [15,10], [15,11], [15,12], [15,13], [15,14], [15,15], [15,16], [15,17], [15,18], [15,19],
          [16,0], [16,1], [16,2], [16,3], [16,4], [16,5], [16,6], [16,7], [16,8], [16,9], [16,10], [16,11], [16,12], [16,13], [16,14], [16,15], [16,16], [16,17], [16,18], [16,19],
          [17,0], [17,1], [17,2], [17,3], [17,4], [17,5], [17,6], [17,7], [17,8], [17,9], [17,10], [17,11], [17,12], [17,13], [17,14], [17,15], [17,16], [17,17], [17,18], [17,19],
          [18,0], [18,1], [18,2], [18,3], [18,4], [18,5], [18,6], [18,7], [18,8], [18,9], [18,10], [18,11], [18,12], [18,13], [18,14], [18,15], [18,16], [18,17], [18,18], [18,19],
          [19,0], [19,1], [19,2], [19,3], [19,4], [19,5], [19,6], [19,7], [19,8], [19,9], [19,10], [19,11], [19,12], [19,13], [19,14], [19,15], [19,16], [19,17], [19,18],
          // Very narrow path (These should NOT be walls)
          // [0,0], [1,0], [2,0], [3,0], [4,0], [5,0], [6,0], [7,0], [8,0], [9,0], [10,0], [11,0], [12,0], [13,0], [14,0], [15,0], [16,0], [17,0], [18,0], [19,0],
          // [19,1], [19,2], [19,3], [19,4], [19,5], [19,6], [19,7], [19,8], [19,9], [19,10], [19,11], [19,12], [19,13], [19,14], [19,15], [19,16], [19,17], [19,18], [19,19]
        ].filter(w => !([
          [0,0], [1,0], [2,0], [3,0], [4,0], [5,0], [6,0], [7,0], [8,0], [9,0], [10,0], [11,0], [12,0], [13,0], [14,0], [15,0], [16,0], [17,0], [18,0], [19,0],
          [19,1], [19,2], [19,3], [19,4], [19,5], [19,6], [19,7], [19,8], [19,9], [19,10], [19,11], [19,12], [19,13], [19,14], [19,15], [19,16], [19,17], [19,18], [19,19]
        ].some(p => p[0] === w[0] && p[1] === w[1])))
      }
    ];
    
    // Chess Pieces
    const chessPieces = {
      'wK': '♔', 'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘', 'wP': '♙',
      'bK': '♚', 'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞', 'bP': '♟'
    };

    // Initial Chess Board Setup
    const initialChessBoard = [
      ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
      ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
      ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
    ];

    // Game State
    let currentPage = 'home';
    let score = 0;
    let timeLeft = 60;
    let timerInterval;
    let currentQuestion = {};
    let answered = false;
    let isCorrect = false;
    let pointsEarned = 0;
    let questionCount = 0;
    let usedQuestions = { riddle: [], puzzle: [], logic: [], math: [] };
    let currentGameMode = '';

    // Maze Game State
    let mazeLevel = 0;
    let mazePlayerPos = {row: 0, col: 0};
    let mazeVisited = [];
    let mazeCompleted = false;

    // Chess Game State
    let chessBoard = JSON.parse(JSON.stringify(initialChessBoard)); // Game state
    let chessTurn = 'w'; // 'w' for white, 'b' for black
    let selectedChessPiece = null;
    let possibleMoves = [];

    // DOM Elements
    const app = document.getElementById('app');

    // Render Functions
    function renderHome() {
      app.innerHTML = `
        <div class="home-container">
          <h1 class="title">🎮 ULTIMATE BRAIN CHALLENGE</h1>
          <p class="subtitle">Uji kecerdasan Anda dengan berbagai jenis permainan pikiran!</p>
          
          <div class="game-modes">
            <div class="game-mode riddle" data-mode="riddle">
              <span class="mode-icon">🔍</span>
              <h3>Teka-Teki</h3>
              <p>Tebak jawaban dari pertanyaan misterius</p>
            </div>
            <div class="game-mode puzzle" data-mode="puzzle">
              <span class="mode-icon">🧩</span>
              <h3>Puzzle</h3>
              <p>Pecahkan teka-teki logika yang menantang</p>
            </div>
            <div class="game-mode logic" data-mode="logic">
              <span class="mode-icon">🤔</span>
              <h3>Logika</h3>
              <p>Latih kemampuan berpikir logis Anda</p>
            </div>
            <div class="game-mode math" data-mode="math">
              <span class="mode-icon">🧮</span>
              <h3>Matematika</h3>
              <p>Uji kecepatan berhitung Anda</p>
            </div>
            <div class="game-mode maze" data-mode="maze">
              <span class="mode-icon">🧭</span>
              <h3>Labirin Extreme</h3>
              <p>20 level labirin menantang</p>
            </div>
            <div class="game-mode chess" data-mode="chess">
              <span class="mode-icon">♟️</span>
              <h3>Catur</h3>
              <p>Permainan strategi klasik</p>
            </div>
          </div>
        </div>
      `;

      // Add event listeners to game modes
      document.querySelectorAll('.game-mode').forEach(mode => {
        mode.addEventListener('click', function() {
          currentGameMode = this.dataset.mode;
          if (currentGameMode === 'maze') {
            startMazeGame();
          } else if (currentGameMode === 'chess') {
            startChessGame();
          } else {
            startGame();
          }
        });
      });

      createParticles();
    }

    function renderGame() {
      currentQuestion = getRandomQuestion(currentGameMode);
      questionCount++;
      answered = false;
      isCorrect = false;
      pointsEarned = 0;

      // Determine question type display
      let typeDisplay = '';
      let typeClass = '';
      switch(currentGameMode) {
        case 'riddle':
          typeDisplay = 'TEKA-TEKI';
          typeClass = 'riddle';
          break;
        case 'puzzle':
          typeDisplay = 'PUZZLE';
          typeClass = 'puzzle';
          break;
        case 'logic':
          typeDisplay = 'LOGIKA';
          typeClass = 'logic';
          break;
        case 'math':
          typeDisplay = 'MATEMATIKA';
          typeClass = 'math';
          break;
      }

      app.innerHTML = `
        <div class="game-container">
          <div class="game-header">
            <div class="timer-container">
              <div class="timer-circle">
                <svg width="60" height="60" viewBox="0 0 44 44">
                  <circle cx="22" cy="22" r="20" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="3"></circle>
                  <circle id="timerPath" cx="22" cy="22" r="20" fill="none" stroke="#00e676" stroke-width="3" 
                    stroke-dasharray="125.6" stroke-dashoffset="0" stroke-linecap="round" transform="rotate(-90 22 22)">
                  </circle>
                </svg>
              </div>
              <span class="timer-text">1:00</span>
            </div>
            <div class="score">Skor: ${score}</div>
          </div>
          
          <div class="question-container">
            <div class="question-type ${typeClass}">${typeDisplay}</div>
            <div class="question">${currentQuestion.text}</div>
            
            ${currentQuestion.type === 'multiple-choice' ? `
              <div class="options">
                ${currentQuestion.options.map((option, index) => `
                  <button class="option-button" data-answer="${option}">${option}</button>
                `).join('')}
              </div>
            ` : `
              <div class="answer-input">
                <input id="userAnswer" class="answer-field" placeholder="Ketik jawaban Anda..." autocomplete="off">
                <button id="submitAnswer" class="submit-button">Submit</button>
              </div>
            `}
            
            <div class="feedback hidden">
              <div class="feedback-message ${isCorrect ? 'correct-feedback' : 'incorrect-feedback'}">
                ${isCorrect ? '🎉' : '❌'}
                ${isCorrect ? `Benar! +${pointsEarned} poin` : `Salah! Jawaban benar: ${currentQuestion.answer}`}
                ${currentQuestion.explanation ? `<div class="explanation">${currentQuestion.explanation}</div>` : ''}
              </div>
              <button id="nextButton" class="next-button">Pertanyaan Berikutnya</button>
            </div>
          </div>
        </div>
      `;

      startTimer();
      setupGameEventListeners();
    }

    function renderMazeGame() {
      const level = mazeLevels[mazeLevel];
      mazePlayerPos = {...level.start};
      mazeVisited = Array(level.rows).fill(null).map(() => Array(level.cols).fill(false)); // Ensure fresh array
      mazeVisited[level.start.row][level.start.col] = true;
      mazeCompleted = false;

      // Set CSS variables for grid size
      document.documentElement.style.setProperty('--rows', level.rows);
      document.documentElement.style.setProperty('--cols', level.cols);

      app.innerHTML = `
        <div class="game-container">
          <div class="game-header">
            <div class="timer-container">
              <div class="timer-circle">
                <svg width="60" height="60" viewBox="0 0 44 44">
                  <circle cx="22" cy="22" r="20" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="3"></circle>
                  <circle id="timerPath" cx="22" cy="22" r="20" fill="none" stroke="#00e676" stroke-width="3" 
                    stroke-dasharray="125.6" stroke-dashoffset="0" stroke-linecap="round" transform="rotate(-90 22 22)">
                  </circle>
                </svg>
              </div>
              <span class="timer-text">1:00</span>
            </div>
            <div class="score">Level: ${mazeLevel + 1}/${mazeLevels.length}</div>
          </div>
          
          <div class="maze-container">
            <div class="maze-level">Labirin Level ${mazeLevel + 1}</div>
            <div class="maze-board" id="mazeBoardElement"></div> {/* Changed ID to avoid conflict */}
            
            <div class="maze-controls">
              <div class="maze-buttons">
                <button id="mazeUp" class="maze-button">↑</button>
                <button id="mazeLeft" class="maze-button">←</button>
                <button id="mazeDown" class="maze-button">↓</button>
                <button id="mazeRight" class="maze-button">→</button>
              </div>
              <button id="mazeReset" class="maze-button">Reset Level</button>
            </div>
          </div>
        </div>
      `;

      renderMazeBoard();
      setupMazeEventListeners();
      startTimer();
    }

    function renderMazeBoard() {
      const level = mazeLevels[mazeLevel];
      const mazeBoardElement = document.getElementById('mazeBoardElement'); // Use new ID
      if (!mazeBoardElement) return; // Guard clause
      mazeBoardElement.innerHTML = '';

      for (let row = 0; row < level.rows; row++) {
        for (let col = 0; col < level.cols; col++) {
          const cell = document.createElement('div');
          cell.className = 'maze-cell';
          
          const isWall = level.walls.some(wall => wall[0] === row && wall[1] === col);
          
          if (isWall) {
            cell.classList.add('maze-wall');
          } else {
            cell.classList.add('maze-path');
            if (row === level.start.row && col === level.start.col) {
              cell.classList.add('maze-start');
            }
            if (row === level.end.row && col === level.end.col) {
              cell.classList.add('maze-end');
            }
            if (row === mazePlayerPos.row && col === mazePlayerPos.col) {
              const player = document.createElement('div');
              player.className = 'maze-player';
              cell.appendChild(player);
            }
            if (mazeVisited[row] && mazeVisited[row][col]) { // Check if row exists
              cell.classList.add('maze-visited');
            }
          }
          mazeBoardElement.appendChild(cell);
        }
      }
    }

    function renderChessGame() {
      app.innerHTML = `
        <div class="game-container">
          <div class="game-header">
            <div class="timer-container">
              <div class="timer-circle">
                <svg width="60" height="60" viewBox="0 0 44 44">
                  <circle cx="22" cy="22" r="20" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="3"></circle>
                  <circle id="timerPath" cx="22" cy="22" r="20" fill="none" stroke="#00e676" stroke-width="3" 
                    stroke-dasharray="125.6" stroke-dashoffset="0" stroke-linecap="round" transform="rotate(-90 22 22)">
                  </circle>
                </svg>
              </div>
              <span class="timer-text">1:00</span>
            </div>
            <div class="score">Catur</div>
          </div>
          
          <div class="chess-container">
            <div class="chess-board" id="chessBoardElement"></div> {/* Changed ID */}
            
            <div class="chess-controls">
              <div class="chess-info">
                <div class="chess-turn">Giliran: ${chessTurn === 'w' ? 'Putih' : 'Hitam'}</div>
                <div class="chess-status">Pilih bidak untuk memulai</div>
              </div>
              <button id="chessReset" class="maze-button">Reset Permainan</button>
            </div>
          </div>
        </div>
      `;

      renderChessBoard();
      setupChessEventListeners();
      startTimer();
    }

    function renderChessBoard() {
      const chessBoardElement = document.getElementById('chessBoardElement'); // Use new ID
      if (!chessBoardElement) return; // Guard clause
      chessBoardElement.innerHTML = '';

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
          square.dataset.row = row; // Add data attributes for easier access
          square.dataset.col = col;
          
          if (selectedChessPiece && possibleMoves.some(move => move.row === row && move.col === col)) {
            square.classList.add('highlight');
          }
          
          const piece = chessBoard[row][col]; // Access global state chessBoard
          if (piece) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'chess-piece';
            pieceElement.textContent = chessPieces[piece];
            pieceElement.dataset.row = row;
            pieceElement.dataset.col = col;
            
            if (selectedChessPiece && selectedChessPiece.row === row && selectedChessPiece.col === col) {
              pieceElement.classList.add('selected');
            }
            square.appendChild(pieceElement);
          }
          chessBoardElement.appendChild(square);
        }
      }
    }

    function renderResults() {
      app.innerHTML = `
        <div class="results-container">
          <div class="results-card">
            <h1 class="results-title">HASIL PERMAINAN</h1>
            
            <div class="score-display">
              <div class="score-circle">
                <div class="score-value">${score}</div>
                <div class="score-label">Poin</div>
              </div>
            </div>
            
            <div class="feedback">
              <h2 class="feedback-title">${getFeedbackTitle()}</h2>
              <p class="feedback-text">${getFeedbackText()}</p>
            </div>
            
            <div class="actions">
              <button id="playAgain" class="action-button play-again">Main Lagi</button>
              <button id="goHome" class="action-button go-home">Kembali ke Beranda</button>
            </div>
          </div>
        </div>
      `;

      if (score >= 100 && currentGameMode !== 'maze' && currentGameMode !== 'chess') { // Confetti for non-maze/chess high scores
        createConfetti();
      }

      document.getElementById('playAgain').addEventListener('click', () => {
        if (currentGameMode === 'maze') {
          startMazeGame();
        } else if (currentGameMode === 'chess') {
          startChessGame();
        } else {
          startGame();
        }
      });
      document.getElementById('goHome').addEventListener('click', () => {
        currentPage = 'home';
        renderHome();
      });
    }

    // Game Logic
    function startGame() {
      currentPage = 'game';
      score = 0;
      timeLeft = 60;
      questionCount = 0;
      usedQuestions = { riddle: [], puzzle: [], logic: [], math: [] };
      renderGame();
    }

    function startMazeGame() {
      currentPage = 'maze';
      // currentGameMode = 'maze'; // Already set when clicking game mode
      mazeLevel = 0;
      score = 0; // Reset score for maze game
      timeLeft = 60;
      renderMazeGame();
    }

    function startChessGame() {
      currentPage = 'chess';
      // currentGameMode = 'chess'; // Already set
      chessBoard = JSON.parse(JSON.stringify(initialChessBoard));
      chessTurn = 'w';
      selectedChessPiece = null;
      possibleMoves = [];
      score = 0; // Chess doesn't use this score system in this version
      timeLeft = 300; // Longer timer for chess
      renderChessGame();
    }

    function getRandomQuestion(mode) {
      if (!questions[mode] || questions[mode].length === 0) {
        return { text: "Tidak ada pertanyaan untuk mode ini.", answer: "", type: "info" };
      }
      const availableQuestions = questions[mode].filter(q => !usedQuestions[mode].includes(q.text));
      
      if (availableQuestions.length === 0) {
        usedQuestions[mode] = []; // Reset if all used
        // Fallback to selecting any question if all were used in a short session
        const allModeQuestions = questions[mode];
        return JSON.parse(JSON.stringify(allModeQuestions[Math.floor(Math.random() * allModeQuestions.length)]));
      }

      const randomIndex = Math.floor(Math.random() * availableQuestions.length);
      const question = availableQuestions[randomIndex];
      usedQuestions[mode].push(question.text);
      
      return JSON.parse(JSON.stringify(question));
    }

    function startTimer() {
      clearInterval(timerInterval);
      const gameDuration = (currentGameMode === 'chess') ? 300 : 60; // 5 mins for chess, 1 min for others
      timeLeft = gameDuration;
      updateTimerDisplay();
      
      timerInterval = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          // For chess, time out might mean a draw or loss depending on rules, here just ends.
          if (currentGameMode === 'chess' && !isKingCaptured()) {
             alert('Waktu habis! Permainan berakhir.');
          } else if (currentGameMode === 'maze' && !mazeCompleted) {
             alert('Waktu habis! Anda gagal menyelesaikan labirin.');
          }
          currentPage = 'results';
          renderResults();
        }
      }, 1000);
    }
    
    function isKingCaptured() {
        let whiteKing = false, blackKing = false;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (chessBoard[r][c] === 'wK') whiteKing = true;
                if (chessBoard[r][c] === 'bK') blackKing = true;
            }
        }
        return !whiteKing || !blackKing;
    }


    function updateTimerDisplay() {
      const minutes = Math.floor(timeLeft / 60);
      const seconds = timeLeft % 60;
      const timerText = document.querySelector('.timer-text');
      const gameDuration = (currentGameMode === 'chess') ? 300 : 60;

      if (timerText) {
        timerText.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        
        const timerPath = document.getElementById('timerPath');
        if (timerPath) {
          const circumference = 2 * Math.PI * 20; // Assuming r=20 from SVG
          const offset = circumference - (timeLeft / gameDuration) * circumference;
          timerPath.style.strokeDashoffset = offset;
          
          if (timeLeft > gameDuration * 0.6) { // >60%
            timerPath.style.stroke = '#00e676'; // Green
          } else if (timeLeft > gameDuration * 0.3) { // >30%
            timerPath.style.stroke = '#ffc107'; // Yellow
          } else {
            timerPath.style.stroke = '#ff5252'; // Red
          }
        }
      }
    }

    function checkAnswer(answer) {
      if (answered) return;
      answered = true;
      
      if (currentQuestion.type === 'riddle' || currentQuestion.type === 'sequence' || 
          currentQuestion.type === 'word-problem' || currentQuestion.type === 'tricky-math' ||
          currentQuestion.type === 'logic-puzzle') {
        isCorrect = answer.trim().toLowerCase() === currentQuestion.answer.toLowerCase();
      } else {
        isCorrect = answer === currentQuestion.answer;
      }
      
      pointsEarned = calculateScore(isCorrect, questionCount);
      if (isCorrect) {
        score += pointsEarned;
      }
      
      const feedbackElement = document.querySelector('.feedback');
      if (!feedbackElement) return;
      feedbackElement.classList.remove('hidden');

      const feedbackMessageEl = feedbackElement.querySelector('.feedback-message');
      if (feedbackMessageEl) {
          feedbackMessageEl.className = `feedback-message ${isCorrect ? 'correct-feedback' : 'incorrect-feedback'}`;
          let messageContent = `${isCorrect ? '🎉' : '❌'} `;
          messageContent += isCorrect ? `Benar! +${pointsEarned} poin` : `Salah! Jawaban benar: ${currentQuestion.answer}`;
          if (currentQuestion.explanation) {
              messageContent += `<div class="explanation">${currentQuestion.explanation}</div>`;
          }
          feedbackMessageEl.innerHTML = messageContent;
      }
      
      if (currentQuestion.type === 'multiple-choice') {
        document.querySelectorAll('.option-button').forEach(button => {
          if (button.dataset.answer === currentQuestion.answer) { // Use data-answer for consistency
            button.classList.add('correct');
          } else if (button.dataset.answer === answer && !isCorrect) {
            button.classList.add('incorrect');
          }
          button.disabled = true;
        });
      } else {
        const answerInput = document.getElementById('userAnswer');
        const submitButton = document.getElementById('submitAnswer');
        if (answerInput) answerInput.disabled = true;
        if (submitButton) submitButton.disabled = true;
      }
      document.querySelector('.score').textContent = `Skor: ${score}`;
    }

    function moveMazePlayer(direction) {
      if (mazeCompleted || timeLeft <= 0) return;
      
      const level = mazeLevels[mazeLevel];
      let newRow = mazePlayerPos.row;
      let newCol = mazePlayerPos.col;
      
      switch(direction) {
        case 'up': newRow--; break;
        case 'down': newRow++; break;
        case 'left': newCol--; break;
        case 'right': newCol++; break;
      }
      
      if (newRow < 0 || newRow >= level.rows || newCol < 0 || newCol >= level.cols) return;
      if (level.walls.some(wall => wall[0] === newRow && wall[1] === newCol)) return;
      
      mazePlayerPos.row = newRow;
      mazePlayerPos.col = newCol;
      if (mazeVisited[newRow]) mazeVisited[newRow][newCol] = true; // Check row exists
      
      if (newRow === level.end.row && newCol === level.end.col) {
        mazeCompleted = true;
        score += 50 * (mazeLevel + 1); // Maze score system
        const scoreDisplay = document.querySelector('.score');
        if (scoreDisplay) scoreDisplay.textContent = `Skor: ${score}`; // Update score display
        
        setTimeout(() => {
          if (mazeLevel < mazeLevels.length - 1) {
            if (confirm(`Selamat! Anda menyelesaikan Level ${mazeLevel + 1}. Lanjut ke level berikutnya?`)) {
              mazeLevel++;
              timeLeft = 60; // Reset timer for next level
              renderMazeGame();
            } else {
              currentPage = 'results'; // Go to results if they don't want to continue
              renderResults();
            }
          } else {
            alert('Selamat! Anda telah menyelesaikan semua level labirin!');
            currentPage = 'results';
            renderResults();
          }
        }, 100);
      }
      renderMazeBoard();
    }

    function calculateScore(isCorrect, qCount) { // qCount is not used here, could be for speed bonus
      if (!isCorrect) return 0;
      const basePoints = 10;
      // Example: const speedBonus = Math.max(0, 15 - (60 - timeLeft)); // Bonus for faster answers
      return basePoints; // Simplified
    }

    function getFeedbackTitle() {
      if (currentGameMode === 'maze' || currentGameMode === 'chess') {
          if (score > 0 || mazeCompleted || (currentGameMode === 'chess' && isKingCaptured())) return "PERMAINAN SELESAI!";
          return "COBA LAGI!";
      }
      if (score >= 100) return "LUAR BIASA! 🎉";
      if (score >= 50) return "HEBAT! 👍";
      return "TERUS BERLATIH! 💪";
    }

    function getFeedbackText() {
      if (currentGameMode === 'maze') {
          return mazeCompleted ? `Anda menyelesaikan labirin dengan skor ${score}!` : "Anda tidak berhasil menyelesaikan labirin tepat waktu.";
      }
      if (currentGameMode === 'chess') {
          // More specific chess feedback can be added
          return isKingCaptured() ? `${chessTurn === 'w' ? 'Hitam' : 'Putih'} menang!` : "Permainan berakhir.";
      }
      if (score >= 100) return "Anda benar-benar ahli dalam teka-teki! Skor fantastis!";
      if (score >= 50) return "Hasil yang sangat bagus! Sedikit lagi bisa mencapai skor sempurna!";
      return "Setiap permainan adalah kesempatan untuk belajar. Coba lagi untuk meningkatkan skor Anda!";
    }

    function getChessPieceMoves(piece, row, col) {
      const moves = [];
      const color = piece[0]; // 'w' or 'b'
      
      switch(piece[1]) { // Piece type
        case 'P': // Pawn
          const direction = color === 'w' ? -1 : 1;
          const oneStepRow = row + direction;
          const twoStepsRow = row + 2 * direction;

          // Move one step forward
          if (oneStepRow >= 0 && oneStepRow < 8 && !chessBoard[oneStepRow][col]) {
            moves.push({row: oneStepRow, col: col});
            // Move two steps forward (from starting position, and if one-step was possible)
            if (((color === 'w' && row === 6) || (color === 'b' && row === 1))) {
                if (twoStepsRow >= 0 && twoStepsRow < 8 && !chessBoard[twoStepsRow][col]) {
                    moves.push({row: twoStepsRow, col: col});
                }
            }
          }

          // Capture diagonally
          for (const dc of [-1, 1]) {
            const captureCol = col + dc;
            if (oneStepRow >= 0 && oneStepRow < 8 && captureCol >= 0 && captureCol < 8 &&
                chessBoard[oneStepRow][captureCol] && chessBoard[oneStepRow][captureCol][0] !== color) {
              moves.push({row: oneStepRow, col: captureCol});
            }
          }
          break;
          
        case 'R': // Rook
        case 'B': // Bishop
        case 'Q': // Queen
          const directions = {
            'R': [[1,0], [-1,0], [0,1], [0,-1]],
            'B': [[1,1], [1,-1], [-1,1], [-1,-1]],
            'Q': [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]]
          }[piece[1]];

          for (const [dr, dc] of directions) {
            for (let i = 1; i < 8; i++) {
              const newRow = row + dr * i;
              const newCol = col + dc * i;
              if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
              if (!chessBoard[newRow][newCol]) {
                moves.push({row: newRow, col: newCol});
              } else {
                if (chessBoard[newRow][newCol][0] !== color) {
                  moves.push({row: newRow, col: newCol});
                }
                break;
              }
            }
          }
          break;
          
        case 'N': // Knight
          for (const [dr, dc] of [[2,1], [2,-1], [-2,1], [-2,-1], [1,2], [1,-2], [-1,2], [-1,-2]]) {
            const newRow = row + dr;
            const newCol = col + dc;
            if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
              if (!chessBoard[newRow][newCol] || chessBoard[newRow][newCol][0] !== color) {
                moves.push({row: newRow, col: newCol});
              }
            }
          }
          break;
          
        case 'K': // King
          for (const [dr, dc] of [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]]) {
            const newRow = row + dr;
            const newCol = col + dc;
            if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
              if (!chessBoard[newRow][newCol] || chessBoard[newRow][newCol][0] !== color) {
                moves.push({row: newRow, col: newCol});
              }
            }
          }
          // Basic castling can be added here if desired
          break;
      }
      return moves;
    }

    function makeChessMove(toRow, toCol) {
      if (!selectedChessPiece || timeLeft <= 0) return;
      
      const fromRow = selectedChessPiece.row;
      const fromCol = selectedChessPiece.col;
      const piece = chessBoard[fromRow][fromCol];
      
      const isValidMove = possibleMoves.some(move => move.row === toRow && move.col === toCol);
      if (!isValidMove) return;
      
      chessBoard[toRow][toCol] = piece;
      chessBoard[fromRow][fromCol] = '';
      
      // Pawn promotion (simple: to Queen)
      if (piece[1] === 'P' && ((piece[0] === 'w' && toRow === 0) || (piece[0] === 'b' && toRow === 7))) {
        chessBoard[toRow][toCol] = piece[0] + 'Q';
      }
      
      chessTurn = chessTurn === 'w' ? 'b' : 'w';
      selectedChessPiece = null;
      possibleMoves = [];
      
      renderChessBoard(); // Update board display first
      
      const chessTurnEl = document.querySelector('.chess-turn');
      const chessStatusEl = document.querySelector('.chess-status');
      if(chessTurnEl) chessTurnEl.textContent = `Giliran: ${chessTurn === 'w' ? 'Putih' : 'Hitam'}`;
      if(chessStatusEl) chessStatusEl.textContent = 'Pilih bidak untuk memulai';

      if (isKingCaptured()) {
        clearInterval(timerInterval); // Stop timer
        setTimeout(() => {
          // Winner is the one whose turn it ISN'T (because the other king was captured on previous turn)
          const winner = chessTurn === 'w' ? 'Hitam' : 'Putih'; 
          alert(`Permainan berakhir! ${winner} menang!`);
          currentPage = 'results';
          renderResults();
        }, 100);
      }
    }

    // Event Listeners Setup
    function setupGameEventListeners() {
      document.querySelectorAll('.option-button').forEach(button => {
        button.addEventListener('click', () => {
          checkAnswer(button.dataset.answer); // Use data-answer
        });
      });
      
      const submitButton = document.getElementById('submitAnswer');
      const userAnswerInput = document.getElementById('userAnswer');

      if (submitButton && userAnswerInput) {
        submitButton.addEventListener('click', () => {
          if (userAnswerInput.value.trim()) {
            checkAnswer(userAnswerInput.value);
          }
        });
        userAnswerInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && userAnswerInput.value.trim()) {
            checkAnswer(userAnswerInput.value);
          }
        });
      }
      
      const nextButton = document.getElementById('nextButton');
      if (nextButton) {
        nextButton.addEventListener('click', () => {
          if (questionCount < 10) { // Example: Limit to 10 questions
             renderGame();
          } else {
             currentPage = 'results';
             renderResults();
          }
        });
      }
    }
    
    let keydownHandlerMaze = null; // To remove specific listener

    function setupMazeEventListeners() {
      document.getElementById('mazeUp').addEventListener('click', () => moveMazePlayer('up'));
      document.getElementById('mazeDown').addEventListener('click', () => moveMazePlayer('down'));
      document.getElementById('mazeLeft').addEventListener('click', () => moveMazePlayer('left'));
      document.getElementById('mazeRight').addEventListener('click', () => moveMazePlayer('right'));
      
      if (keydownHandlerMaze) {
        document.removeEventListener('keydown', keydownHandlerMaze);
      }
      keydownHandlerMaze = (e) => {
        if (currentPage !== 'maze' || mazeCompleted || timeLeft <= 0) return;
        // Prevent page scroll with arrow keys
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }
        switch(e.key) {
          case 'ArrowUp': moveMazePlayer('up'); break;
          case 'ArrowDown': moveMazePlayer('down'); break;
          case 'ArrowLeft': moveMazePlayer('left'); break;
          case 'ArrowRight': moveMazePlayer('right'); break;
        }
      };
      document.addEventListener('keydown', keydownHandlerMaze);
      
      document.getElementById('mazeReset').addEventListener('click', () => {
        timeLeft = 60; // Reset timer on level reset
        renderMazeGame();
      });
    }
    
    let chessBoardClickHandler = null;

    function setupChessEventListeners() {
      const chessBoardElement = document.getElementById('chessBoardElement');
      if (!chessBoardElement) return;

      if (chessBoardClickHandler) {
          chessBoardElement.removeEventListener('click', chessBoardClickHandler);
      }
      
      chessBoardClickHandler = (e) => {
        if (timeLeft <= 0) return;
        const target = e.target;
        const square = target.closest('.chess-square');
        const pieceElement = target.closest('.chess-piece');
        
        if (pieceElement) {
          const row = parseInt(pieceElement.dataset.row);
          const col = parseInt(pieceElement.dataset.col);
          const pieceName = chessBoard[row][col];
          
          if (pieceName && pieceName[0] === chessTurn) {
            selectedChessPiece = {row, col, piece: pieceName};
            possibleMoves = getChessPieceMoves(pieceName, row, col);
            const chessStatusEl = document.querySelector('.chess-status');
            if(chessStatusEl) chessStatusEl.textContent = 'Pilih tujuan atau bidak lain';
            renderChessBoard(); // Re-render to show selection and highlights
          }
        } else if (square && selectedChessPiece) {
          const toRow = parseInt(square.dataset.row);
          const toCol = parseInt(square.dataset.col);
          makeChessMove(toRow, toCol);
        }
      };
      chessBoardElement.addEventListener('click', chessBoardClickHandler);
      
      document.getElementById('chessReset').addEventListener('click', () => {
        startChessGame();
      });
    }

    // Effects
    function createParticles() {
      const existingParticles = document.querySelector('.particles-container');
      if (existingParticles) existingParticles.remove();

      const particlesContainer = document.createElement('div');
      particlesContainer.className = 'particles-container'; // Add class for potential removal
      particlesContainer.style.position = 'fixed';
      particlesContainer.style.top = '0';
      particlesContainer.style.left = '0';
      particlesContainer.style.width = '100%';
      particlesContainer.style.height = '100%';
      particlesContainer.style.pointerEvents = 'none';
      particlesContainer.style.zIndex = '-1';
      document.body.appendChild(particlesContainer);

      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');
        const size = Math.random() * 5 + 2;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        const animationDuration = Math.random() * 20 + 10;
        particle.style.animation = `float ${animationDuration}s infinite ease-in-out`;
        particle.style.animationDelay = `${Math.random() * 5}s`;
        particle.style.opacity = Math.random() * 0.5 + 0.1;
        particlesContainer.appendChild(particle);
      }
    }

    function createConfetti() {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
      const confettiContainer = document.createElement('div'); // Container for confetti
      confettiContainer.style.position = 'fixed';
      confettiContainer.style.top = '0';
      confettiContainer.style.left = '0';
      confettiContainer.style.width = '100%';
      confettiContainer.style.height = '100%';
      confettiContainer.style.pointerEvents = 'none';
      confettiContainer.style.zIndex = '1000'; // Ensure confetti is on top
      document.body.appendChild(confettiContainer);

      for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        // Removed particle class to avoid conflict with background particles
        const size = Math.random() * 10 + 5;
        confetti.style.width = `${size}px`;
        confetti.style.height = `${size}px`;
        confetti.style.position = 'absolute'; // Position within container
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.top = `-${size}px`; // Start above screen
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.borderRadius = '50%';
        const animationDuration = Math.random() * 3 + 2;
        confetti.style.animation = `confetti ${animationDuration}s linear forwards`;
        confetti.style.animationDelay = `${Math.random() * 0.5}s`;
        confettiContainer.appendChild(confetti);
        
        setTimeout(() => {
          confetti.remove();
          if (confettiContainer.children.length === 0) { // Remove container when all confetti gone
            confettiContainer.remove();
          }
        }, animationDuration * 1000 + 500); // Add buffer for removal
      }
    }

    // Initialize
    renderHome();
  </script>
</body>
</html>
